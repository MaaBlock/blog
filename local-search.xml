<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多dll链接同一个lib的内存情况</title>
    <link href="/blog/2025/08/27/memery-in-mutil-dll-include-lib/"/>
    <url>/blog/2025/08/27/memery-in-mutil-dll-include-lib/</url>
    
    <content type="html"><![CDATA[<p>在大型项目（尤其是游戏开发）中，我们经常会将一些公用代码编译成静态库（<code>.lib</code>），然后由不同的动态库（<code>.dll</code>）模块去链接。这样做可以提高编译效率、方便代码复用。然而，这种做法会引出一个非常关键且容易被忽略的内存问题：<strong>静态库中的全局变量（或静态变量）会在每一个链接它的DLL中都创建一份独立的副本。</strong></p><h3 id="为什么会产生多份副本？"><a href="#为什么会产生多份副本？" class="headerlink" title="为什么会产生多份副本？"></a>为什么会产生多份副本？</h3><p>要理解这个问题，首先需要明白静态库（<code>.lib</code>）和动态库（<code>.dll</code>）的链接原理。</p><ol><li><p><strong>静态链接 (.lib)</strong>：<br>静态库本质上是一个或多个目标文件（<code>.obj</code>）的归档集合。在链接阶段，链接器会从静态库中提取被引用的代码和数据，并将其<strong>直接复制</strong>到最终生成的可执行文件（在这里是 <code>.dll</code>）中。这个过程就像是把库的代码和数据“拷贝粘贴”进了你的模块里。</p></li><li><p><strong>动态链接 (.dll)</strong>：<br>动态库则不同。当一个模块链接一个动态库时，它只记录了需要调用哪些函数和使用哪些数据。在程序运行时，操作系统（加载器）会将这个 <code>.dll</code> 文件加载到进程的虚拟地址空间中。关键在于，<strong>对于同一个进程，一个DLL只会被加载一次</strong>，所有依赖它的模块都会共享这同一份DLL的内存。</p></li></ol><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>假设我们有以下结构：</p><ul><li><code>common.lib</code>: 一个静态库，定义了一个全局变量 <code>int g_global_variable = 0;</code>。</li><li><code>ModuleA.dll</code>: 一个动态库，链接了 <code>common.lib</code>。</li><li><code>ModuleB.dll</code>: 另一个动态库，也链接了 <code>common.lib</code>。</li><li><code>Game.exe</code>: 主程序，会加载 <code>ModuleA.dll</code> 和 <code>ModuleB.dll</code>。</li></ul><p>当 <code>Game.exe</code> 运行起来后，内存布局会是这样的：</p><ul><li>链接器在编译 <code>ModuleA.dll</code> 时，会将 <code>common.lib</code> 中的 <code>g_global_variable</code> 复制一份到 <code>ModuleA.dll</code> 的数据段中。</li><li>同样，在编译 <code>ModuleB.dll</code> 时，链接器也会将 <code>g_global_variable</code> 复制一份到 <code>ModuleB.dll</code> 的数据段中。</li></ul><p>结果就是，当 <code>Game.exe</code> 加载了这两个DLL后，进程的内存里会存在<strong>两个</strong> <code>g_global_variable</code> 变量：</p><ul><li>一个属于 <code>ModuleA.dll</code>。</li><li>另一个属于 <code>ModuleB.dll</code>。</li></ul><p>它们位于不同的内存地址，彼此完全独立。如果在 <code>ModuleA.dll</code> 中修改了这个全局变量，<code>ModuleB.dll</code> 中的那一份<strong>不会受到任何影响</strong>。</p><h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><p>这种行为常常会导致一些隐蔽的Bug，尤其是在你期望这个全局变量是“全局唯一”的时候：</p><ol><li><strong>状态不一致</strong>：如果你用它来做单例模式（Singleton）或者状态机，那么每个DLL都会有自己的单例实例和状态，导致逻辑错乱。</li><li><strong>资源重复初始化</strong>：如果这个全局变量是一个复杂的对象，它的构造函数负责初始化某些系统资源（比如日志文件、渲染设备句柄等），那么这些资源可能会被重复创建和初始化，引发冲突或性能问题。</li><li><strong>内存浪费</strong>：虽然单个变量影响不大，但如果静态库中包含大量全局数据，这会造成不必要的内存冗余。</li></ol><h3 id="变通方案：显式访问特定模块的数据"><a href="#变通方案：显式访问特定模块的数据" class="headerlink" title="变通方案：显式访问特定模块的数据"></a>变通方案：显式访问特定模块的数据</h3><p>在某些特殊场景下，我们可能并不想消除多份副本，而是需要一种方式来明确地访问和管理它们。例如，主程序可能需要查询或设置每个独立模块内部的状态。</p><p>在这种情况下，我们不能直接访问全局变量，因为它的访问作用域被限制在了各自的DLL内部。正确的做法是在每个DLL中提供导出的“访问器”函数（Accessor Functions）。</p><p>回到我们的例子：</p><ul><li><p><strong><code>ModuleA.dll</code></strong> 可以导出两个函数来操作它内部的 <code>g_global_variable</code> 副本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ModuleA_api.h</span><br>__declspec(dllexport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetModuleAVar</span><span class="hljs-params">()</span></span>;<br>__declspec(dllexport) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetModuleAVar</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ModuleA.cpp (implementation)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common_lib_header.h&quot;</span> <span class="hljs-comment">// 假设 g_global_variable 在这里声明</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetModuleAVar</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> g_global_variable; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetModuleAVar</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; g_global_variable = val; &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong><code>ModuleB.dll</code></strong> 也做类似的操作。</p></li></ul><p>这样，<code>Game.exe</code> 就可以通过调用这些特定的函数，来精确地控制和查询每个模块的内部状态，将一个原本隐蔽的问题转化为了一个清晰、可控的设计。</p><p><strong>适用场景</strong>：</p><ul><li>每个模块需要维护独立的缓存或统计数据。</li><li>主程序作为协调者，需要检查或配置各个子模块的状态。</li></ul><p>然而，这并没有解决“全局唯一状态”的需求。如果你的目标是让所有模块共享同一个变量，那么下面的方法才是根本的解决方案。</p><h3 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h3><p>要确保全局变量在整个进程中只有一份实例，正确的做法是：</p><p><strong>将需要共享的数据和代码也放到一个独立的动态库（<code>.dll</code>）中。</strong></p><p>例如，我们可以创建一个 <code>Shared.dll</code>，将 <code>g_global_variable</code> 放在里面。然后让 <code>ModuleA.dll</code> 和 <code>ModuleB.dll</code> 都去链接这个 <code>Shared.dll</code>。</p><p>这样，当 <code>Game.exe</code> 启动时：</p><ol><li>操作系统加载 <code>Shared.dll</code> 到内存中，<code>g_global_variable</code> 只有一份实例。</li><li>接着加载 <code>ModuleA.dll</code> 和 <code>ModuleB.dll</code>。</li><li>当这两个模块访问 <code>g_global_variable</code> 时，它们访问的都是 <code>Shared.dll</code> 中那份唯一的实例。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在C++项目（尤其是使用多DLL架构的Windows平台）中，必须清晰地认识到静态库和动态库在内存管理上的区别。</p><ul><li><strong>静态库 (<code>.lib</code>)</strong>：代码和数据被复制到每个链接它的模块中，导致数据多份副本。</li><li><strong>动态库 (<code>.dll</code>)</strong>：被所有模块共享，数据在进程中只有一份实例。</li></ul><p>因此，<strong>“需要跨模块共享的状态和数据，必须放在动态库中”</strong>，这是一个需要牢记的核心原则。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++中的编码问题</title>
    <link href="/blog/2025/08/26/encoding-cpp/"/>
    <url>/blog/2025/08/26/encoding-cpp/</url>
    
    <content type="html"><![CDATA[<h2 id="1-源文件编码-字符串实际存储编码"><a href="#1-源文件编码-字符串实际存储编码" class="headerlink" title="1.源文件编码(字符串实际存储编码)"></a>1.源文件编码(字符串实际存储编码)</h2><p>源代码文件的编码，是字符串实际存储的代码（字面量存储的编码）</p><h2 id="2-编译器输入编码-source-character"><a href="#2-编译器输入编码-source-character" class="headerlink" title="2.编译器输入编码(source character)"></a>2.编译器输入编码(source character)</h2><p>编译器认为的字符串的编码（编译器认为的字面量（不加前缀的情况下）编码）</p><h2 id="3-执行编码"><a href="#3-执行编码" class="headerlink" title="3.执行编码"></a>3.执行编码</h2><p>exe实际存储的字符串的编码，编译器会在编译时转换为该执行编码</p><h2 id="4-控制台显示编码"><a href="#4-控制台显示编码" class="headerlink" title="4.控制台显示编码"></a>4.控制台显示编码</h2><p>通过chcp可改变和获取</p><h2 id="编码转换流程"><a href="#编码转换流程" class="headerlink" title="编码转换流程"></a>编码转换流程</h2><pre><code class=" mermaid">flowchart LR    A[源文件] --&gt; B[编译器处理]    subgraph B [编译器处理阶段]        B1[源文件编码&lt;br&gt;UTF-8/GBK等]        B2[被编译器视为 编译器输入编码]        B3[转换为执行编码]        B1--&gt;B2--&gt;B3    end    B --&gt; C&#123;输出方式&#125;    C --&gt; D[标准输出流 cout]    C --&gt; E[宽字节输出流 wcout]    subgraph D [cout 处理流程]        D1[字符串按执行编码&lt;br&gt;直接输出字节]        D2[控制台接收字节流]        D3[控制台以显示编码解读]        D1--&gt;D2--&gt;D3    end    subgraph E [wcout 处理流程]        E1[字符串被视为执行编码]        E2[转换为wcout的locale指定编码]        E3[控制台接收转换后字节]        E4[控制台以显示编码解读]        E1--&gt;E2--&gt;E3--&gt;E4        F[locale对象] --&gt; E2    end    D3 --&gt; G[显示结果]    E4 --&gt; G    style A fill:#e1f5fe    style B fill:#f3e5f5    style D fill:#fff3e0    style E fill:#e8f5e9    style F fill:#ffebee    style G fill:#bbdefb</code></pre><h2 id="CMake中设置编译器输入执行编码"><a href="#CMake中设置编译器输入执行编码" class="headerlink" title="CMake中设置编译器输入执行编码"></a>CMake中设置编译器输入执行编码</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(MSVC) <span class="hljs-comment"># msvc</span><br>    <span class="hljs-keyword">target_compile_options</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE<br>        /source-charset:utf-<span class="hljs-number">8</span>    <span class="hljs-comment"># 输入编码</span><br>        /execution-charset:utf-<span class="hljs-number">8</span> <span class="hljs-comment"># 执行编码</span><br>    )<br><span class="hljs-keyword">else</span>() <span class="hljs-comment"># gcc 或 clang</span><br>    <span class="hljs-keyword">target_compile_options</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <br>        -finput-charset=UTF-<span class="hljs-number">8</span>     <span class="hljs-comment"># 输入编码</span><br>        -fexec-charset=UTF-<span class="hljs-number">8</span>      <span class="hljs-comment"># 执行编码</span><br>    )<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="u8-u-U的作用"><a href="#u8-u-U的作用" class="headerlink" title="u8,u,U的作用"></a>u8,u,U的作用</h2><p>u8 单独将该字面量的执行编码设置为utf8<br>u 单独将该字面量的执行编码设置为utf16<br>U 单独将该字面量的执行编码设置为utf32</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>文件编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>assimp-data-graph</title>
    <link href="/blog/2025/08/24/assimp-data-graph/"/>
    <url>/blog/2025/08/24/assimp-data-graph/</url>
    
    <content type="html"><![CDATA[<pre><code class=" mermaid">graph LRScene[aiScene]    Scene --&gt; RootNode[aiNode* mRootNode]    Scene --&gt; Meshes[aiMesh** mMeshes]    Scene --&gt; Materials[aiMaterial** mMaterials]    Scene --&gt; Animations[aiAnimation** mAnimations]    Scene --&gt; Textures[aiTexture** mTextures]    Scene --&gt; Lights[aiLight** mLights]    Scene --&gt; Cameras[aiCamera** mCameras]    Scene --&gt; Skeletons[aiSkeleton** mSkeletons]    Scene --&gt; MetaData[aiMetadata* mMetaData]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>assimp</tag>
      
      <tag>3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言数组会被std::is_pointer&lt;T&gt;检测为指针吗？</title>
    <link href="/blog/2025/08/17/is-c-style-array-will-be-cheaked-to-pointer/"/>
    <url>/blog/2025/08/17/is-c-style-array-will-be-cheaked-to-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="结果及结论"><a href="#结果及结论" class="headerlink" title="结果及结论"></a>结果及结论</h2><p>按引用传递:不会<br>按值传递:会<br>c语言数组不会被std::is_pointer<T>检测为指针。<br>如果按值传递退化为指针则会</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_type_by_value</span><span class="hljs-params">(T param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Type: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::is_pointer&lt;T&gt;::value: &quot;</span> &lt;&lt; std::is_pointer&lt;T&gt;::value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::is_array&lt;T&gt;::value: &quot;</span> &lt;&lt; std::is_array&lt;T&gt;::value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_type_by_ref</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Type: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::is_pointer&lt;T&gt;::value: &quot;</span> &lt;&lt; std::is_pointer&lt;T&gt;::value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;std::is_array&lt;T&gt;::value: &quot;</span> &lt;&lt; std::is_array&lt;T&gt;::value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 测试 C 数组</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Testing C array (int[5]) - by value:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">test_type_by_value</span>(arr);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Testing C array (int[5]) - by reference:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">test_type_by_ref</span>(arr);<br><br>    <span class="hljs-comment">// 测试指针</span><br>    <span class="hljs-type">int</span>* ptr = arr;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Testing pointer (int*) - by value:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">test_type_by_value</span>(ptr);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Testing pointer (int*) - by reference:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">test_type_by_ref</span>(ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Testing</span> <span class="hljs-string">C</span> <span class="hljs-string">array</span> <span class="hljs-string">(int[5])</span> <span class="hljs-bullet">-</span> <span class="hljs-attr">by value:</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">int</span> <span class="hljs-string">*</span> <span class="hljs-string">__ptr64</span><br><span class="hljs-string">std::is_pointer&lt;T&gt;::value:</span> <span class="hljs-number">1</span><br><span class="hljs-string">std::is_array&lt;T&gt;::value:</span> <span class="hljs-number">0</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">Testing</span> <span class="hljs-string">C</span> <span class="hljs-string">array</span> <span class="hljs-string">(int[5])</span> <span class="hljs-bullet">-</span> <span class="hljs-attr">by reference:</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">int</span> [<span class="hljs-number">5</span>]<br><span class="hljs-string">std::is_pointer&lt;T&gt;::value:</span> <span class="hljs-number">0</span><br><span class="hljs-string">std::is_array&lt;T&gt;::value:</span> <span class="hljs-number">1</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">Testing pointer (int*) - by value:</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">int</span> <span class="hljs-string">*</span> <span class="hljs-string">__ptr64</span><br><span class="hljs-string">std::is_pointer&lt;T&gt;::value:</span> <span class="hljs-number">1</span><br><span class="hljs-string">std::is_array&lt;T&gt;::value:</span> <span class="hljs-number">0</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">Testing pointer (int*) - by reference:</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">int</span> <span class="hljs-string">*</span> <span class="hljs-string">__ptr64</span><br><span class="hljs-string">std::is_pointer&lt;T&gt;::value:</span> <span class="hljs-number">1</span><br><span class="hljs-string">std::is_array&lt;T&gt;::value:</span> <span class="hljs-number">0</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>可以看到c语言数组不会被std::is_pointer<T>检测为指针。<br>按值传递退化为指针则会被检测为指针</p>]]></content>
    
    
    
    <tags>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程范式</title>
    <link href="/blog/2025/08/14/programmer-pattern/"/>
    <url>/blog/2025/08/14/programmer-pattern/</url>
    
    <content type="html"><![CDATA[<pre><code class=" mermaid">graph TD    A[编程范式] --&gt; B[命令式编程&lt;br/&gt;Imperative Programming]    A --&gt; C[声明式编程&lt;br/&gt;Declarative Programming]        B --&gt; D[过程式编程&lt;br/&gt;Procedural Programming]    B --&gt; E[面向对象编程&lt;br/&gt;Object-Oriented Programming]        C --&gt; F[函数式编程&lt;br/&gt;Functional Programming]    C --&gt; G[逻辑式编程&lt;br/&gt;Logic Programming]    C --&gt; H[响应式编程&lt;br/&gt;Reactive Programming]        style A fill:#e1f5fe    style B fill:#fff3e0    style C fill:#f3e5f5    style D fill:#e8f5e8    style E fill:#fff8e1    style F fill:#fce4ec    style G fill:#e0f2f1    style H fill:#f1f8e9</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把**文本**替换为使用html的加粗标识</title>
    <link href="/blog/2025/08/14/regex-replace-sharp-to-b/"/>
    <url>/blog/2025/08/14/regex-replace-sharp-to-b/</url>
    
    <content type="html"><![CDATA[<h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">\*\*(.*?)\*\*<br></code></pre></td></tr></table></figure><h1 id="替换为"><a href="#替换为" class="headerlink" title="替换为"></a>替换为</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">&lt;b&gt;$1&lt;/b&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
